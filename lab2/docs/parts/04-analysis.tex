\chapter{Аналитическая часть}

В этом разделе будут рассмотрены классический алгоритм умножения матриц и алгоритм Винограда, а также его оптимизированная версия.

\section{Матрица}

\textbf{Матрицей} называют таблицу чисел $a_{ik}$ вида
\begin{equation}
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mn}
	\end{pmatrix},
\end{equation}
состоящую из $m$ строк и $n$ столбцов ~\cite{book_matrix}. Числа $a_{ik}$ называются её \textit{элементами}.

Пусть $A$ --- матрица, тогда $A_{i,j}$ --- элемент этой матрицы, который находится на \textit{i-ой} строке и \textit{j-ом} столбце.

Можно выделить следующие операции над матрицами:
\begin{enumerate}[label=\arabic*)]
	\item сложение матриц одинакового размера;
	\item вычитание матриц одинакового размера;
	\item умножение матриц в случае, если количество столбцов первой матрицы равно количеству строк второй матрицы. В итоговой матрице количество строк будет, как у первой матрицы, а столбцов --- как у второй.
\end{enumerate}

\textit{Замечание:} операция умножения матриц не коммутативна --- если \textit{A} и \textit{B} --- квадратные матрицы, а \textit{C} --- результат их перемножения, то произведение \textit{A} $\times$ \textit{B} и \textit{B} $\times$ \textit{A} дадут разный результат \textit{C}.

\clearpage

\section{Классический алгоритм}

Пусть даны две матрицы:

\begin{equation}
	A_{lm} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	\quad
	B_{mn} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}
тогда матрица $C$
\begin{equation}
	C_{ln} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}
где
\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
\end{equation}
будет называться произведением матриц $A$ и $B$ ~\cite{book_matrix}.

% \begin{multline}
\section{Алгоритм Винограда}

Алгоритм Винограда --- алгоритм умножения квадратных матриц~\cite{book_vinograd}.
В 1987 году Дон Копперсмит и Виноград опубликовали метод, содержащий асимптотическую сложность $O(n^{2,3755})$ и улучшили его в 2011 до $O(n^{2,373})$, где $n$ --- размер сторон матрицы.
После доработки он стал обладать лучшей асимптотикой среди всех алгоритмов умножения матриц.

Рассмотрим пример, пусть есть два вектора $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$.
Их скалярное произведение равно: $U \times W = u_1\cdot w_1 + u_2\cdot w_2 + u_3\cdot w_3 + u_4\cdot w_4$, что
эквивалентно:
\begin{equation}
	\label{equ:example_scal_mul}
	\begin{gathered}
		U \cdot W = (u_1 + w_2)\cdot (u_2 + w_1) + (u_3 + w_4)\cdot(u_4 + w_3) -\\
		- u_1\cdot u_2 - u_3\cdot u_4 - w_1\cdot w_2 - w_3\cdot w_4.
	\end{gathered}
\end{equation}

Пусть матрицы $A, B, C$, ранее определенных размеров.

Упомянутое скалярное произведение, по замыслу Винограда, можно выполнить по формуле:
\begin{equation}
	\label{equ:example_scal_mul_matrix}
	\begin{gathered}
		C_{ij} = \sum_{k=1}^{q/2}(a_{i,2k-1} + b_{2k,j})\cdot(a_{i,2k} + b_{2k-1,j}) -\\
		- \sum_{k=1}^{q/2} a_{i,2k-1}\cdot a_{i,2k} - \sum_{k=1}^{q/2} b_{2k-1,j}\cdot b_{2k,j}.
	\end{gathered}
\end{equation}

Казалось бы, это только увеличит количество арифметических операций по сравнению с классическим методом, однако Виноград предложил находить второе и третье слагаемые в (\ref{equ:example_scal_mul_matrix}) предварительном этапе вычислений, заранее для каждой строки матрицы $A$ и столбца $B$ соответственно.
Так, вычислив единожды для строки $i$ матрицы $A$ значение выражения $\sum_{k=1}^{q/2}a_{i,2k-1}\cdot a_{i,2k}$ его можно далее использовать m раз при нахождении элементов $i$-ой строчки матрицы $C$.
Аналогично, вычислив единожды для столбца $j$ матрицы $B$ значение выражения $\sum_{k=1}^{q/2} b_{2k-1,j}\cdot b_{2k,j}$ его можно далее использовать n раз при нахождении элементов $j$-ого столбца матрицы $C$~\cite{book_vinograd}.

За счёт предварительной обработки данных можно получить прирост производительности: несмотря на то, что полученное выражение требует большего количества умножений и сложений, чем стандартное умножение матриц, выражение в правой части равенства можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы.
Это позволит выполнить лишь два умножения и пять сложений для квадратной матрицы размером четыре, при учёте, что потом будет сложено только с двумя предварительно посчитанными суммами соседних элементов текущих строк и столбцов. Операция сложения выполняется
быстрее, поэтому на практике алгоритм должен работать быстрее обычного алгоритма перемножения матриц.

Стоит упомянуть, что при нечётном значении размера любого из сторон матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда}

При программной реализации рассмотренного выше алгоритма Винограда можно сделать следующие оптимизации:
\begin{enumerate}
	\item значение $\frac{N}{2}$, используемое как ограничения цикла подсчёта предварительных данных, можно кэшировать;
	\item операцию умножения на 2 программно эффективнее реализовывать как побитовый сдвиг влево на 1;
	\item операции сложения и вычитания с присваиванием следует реализовывать при помощи соответствующего оператора $+=$ или $-=$ (при наличии данных операторов в выбранном языке программирования).
\end{enumerate}

\section*{Вывод}
В данном разделе были рассмотрены алгоритмы умножения матриц, а именно классический алгоритм и алгоритм Винограда, который имеет большую эффективность засчёт предварительных вычислений.
Также были рассмотрены оптимизации, которые можно учесть при программной реализации алгоритма Винограда.

Алгоритмы будут получать на вход две матрицы, причём количество столбцов одной матрицы должно совпадать с количеством строк второй матрицы.
При вводе пустой матрицы будет выведено сообщение об ошибке.
Требуется реализовать программное обеспечение, которое даёт возможность выбрать один из алгоритмов, ввести две матрицы и вывести результат их перемножения.
Также необходимо провести замеры времени работы реализаций алгоритмов для чётных и нечётных размеров любых из сторон матриц и сравнить результаты, используя графическое представление.
